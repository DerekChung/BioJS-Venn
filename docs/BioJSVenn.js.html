<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width" charset="utf-8">
    <title>Title Not Set</title>
    <link rel="stylesheet" href="http://getbootstrap.com/2.3.2/assets/css/bootstrap.css">
    <link rel="stylesheet" href="http://getbootstrap.com/2.3.2/assets/css/bootstrap-responsive.css">
    <link rel="stylesheet" href="http://getbootstrap.com/2.3.2/assets/css/docs.css">
    <style>
      body > .navbar .brand {
        float:left;
        text-shadow: rgba(255, 255, 255, 0.0980392) 0px 1px 0px, rgba(255, 255, 255, 0.4) 0px 0px 30px;
        color: white;
        margin-left:0px;
        font-weight:normal;
      }
      
      .bs-docs-sidenav.affix {
        box-shadow: 0 0 20px 1px rgba(0, 0, 0, 0.5);
        z-index: 10;
      }
      
      .bs-docs-sidenav i{
        width: 8px;
        height: 8px;
        padding: 0px;
        margin: 0px;
        display: inline-block;
        margin-right:0.5em;
      }
      
      .bs-docs-sidenav > li > a {
          word-wrap: break-word;
      }
      
      .bs-docs-sidenav > li:first-child > a {
        border-top-right-radius: 6px;
        border-top-left-radius: 6px;
      }
      
      code[class*="language-"],pre[class*="language-"]{color:black;text-shadow:0 1px white;font-family:Consolas,Monaco,'Andale Mono',monospace;direction:ltr;text-align:left;white-space:pre;word-spacing:normal;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none}pre[class*="language-"]{padding:1em;margin:.5em 0;overflow:auto}:not(pre)>code[class*="language-"],pre[class*="language-"]{background:#f5f2f0}:not(pre)>code[class*="language-"]{padding:.1em;border-radius:.3em}.token.comment,.token.prolog,.token.doctype,.token.cdata{color:slategray}.token.punctuation{color:#999}.namespace{opacity:.7}.token.property,.token.tag,.token.boolean,.token.number{color:#905}.token.selector,.token.attr-name,.token.string{color:#690}.token.operator,.token.entity,.token.url,.language-css .token.string,.style .token.string{color:#a67f59;background:hsla(0,0%,100%,.5)}.token.atrule,.token.attr-value,.token.keyword{color:#07a}.token.regex,.token.important{color:#e90}.token.important{font-weight:bold}.token.entity{cursor:help}
      div.description {margin: 14px 0; padding-top: 14px; border-bottom:1px solid #eee; }
      .tags {}
      .ctx-type {
        display:inline-block;
        margin-right:0.5em;
        //- float:right; margin-top:8px
      }
      
      footer iframe{vertical-align:middle;}
      
    </style>
  </head>
  <body data-spy="scroll" data-target=".scrollspy">
    <div class="navbar navbar-inverse navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container"><a class="brand">Doxx</a>
          <div class="nav-collapse collapse">
            <ul class="nav pull-right sponsored"></ul>
          </div>
        </div>
      </div>
    </div>
    <header id="overview" class="jumbotron subhead">
      <div class="container">
        <h1>Title Not Set</h1>
        <p class="lead"></p>
      </div>
    </header>
    <div class="container">
      <div class="row">
        <div class="span3 bs-docs-sidebar">
          <ul class="nav nav-list bs-docs-sidenav affix-top">
            <li><a href="index.html">Main</a></li>
            <li class="active"><a href="BioJSVenn.js.html">BioJSVenn.js</a></li>
          </ul>
          <div class="scrollspy">
            <ul class="nav nav-list bs-docs-sidenav affix-top">
              <li><a href="#saveAsPNG"><i class="alert alert-info"></i><span>saveAsPNG</span></a>
              </li>
              <li><a href="#saveLastRequireSets"><i class="alert alert-info"></i><span>saveLastRequireSets</span></a>
              </li>
              <li><a href="#saveAllSets"><i class="alert alert-info"></i><span>saveAllSets</span></a>
              </li>
              <li><a href="#setClickCallback"><i class="alert alert-info"></i><span>setClickCallback</span></a>
              </li>
              <li><a href="#getNumberOfSets"><i class="alert alert-info"></i><span>getNumberOfSets</span></a>
              </li>
              <li><a href="#getMaxVennSets"><i class="alert alert-info"></i><span>getMaxVennSets</span></a>
              </li>
              <li><a href="#switchToAutoMode"><i class="alert alert-info"></i><span>switchToAutoMode</span></a>
              </li>
              <li><a href="#switchToPredfinedMode"><i class="alert alert-info"></i><span>switchToPredfinedMode</span></a>
              </li>
              <li><a href="#updateListName"><i class="alert alert-info"></i><span>updateListName</span></a>
              </li>
              <li><a href="#getRequiredList"><i class="alert alert-info"></i><span>getRequiredList</span></a>
              </li>
              <li><a href="#getRequiredListByName"><i class="alert alert-info"></i><span>getRequiredListByName</span></a>
              </li>
              <li><a href="#getAllIntersectSets"><i class="alert alert-info"></i><span>getAllIntersectSets</span></a>
              </li>
              <li><a href="#updateList"><i class="alert alert-info"></i><span>updateList</span></a>
              </li>
              <li><a href="#addList"><i class="alert alert-info"></i><span>addList</span></a>
              </li>
              <li><a href="#readJSON"><i class="alert alert-info"></i><span>readJSON</span></a>
              </li>
              <li><a href="#updateAllList"><i class="alert alert-info"></i><span>updateAllList</span></a>
              </li>
            </ul>
          </div>
        </div>
        <div class="span9">
          <section id="saveAsPNG">
            <h1>saveAsPNG</h1>
            <h5 class="subheader"></h5>
            <p>
              <div class="label label-info radius ctx-type">method</div><span>saveAsPNG()</span>
            </p>
          </section>
          <div class="description"><p>Save the Venn diagram into PNG.</p> </div>
          <pre><code class="language-javascript">saveAsPNG: function(){
	var canvas = d3.select( &quot;body&quot; )
					.append( &quot;canvas&quot; )
					.attr( &quot;width&quot;, w )
					.attr( &quot;height&quot;, h )
					.style( &quot;display&quot;, &quot;none&quot; )
	//get the html from svg element
	var html = svg.attr(&quot;version&quot;, 1.1)
				.attr(&quot;xmlns&quot;, &quot;http://www.w3.org/2000/svg&quot;)
				.node().parentNode.innerHTML;

	var context = canvas.node().getContext(&quot;2d&quot;);
	var imgsrc = 'data:image/svg+xml;base64,'+ btoa(html);

	var image = new Image;
	image.src = imgsrc;

	var IntersectionSet = this._getIntersectSets();

	image.onload = function () {
		context.drawImage( image, 0, 0 );

		//try to add back text into the graph as changing from svg to canvas lose all &lt;text&gt; element.
		var textPosition = [];
		for ( key in IntersectionSet ){
			var text = d3.select( &quot;#text&quot; + key )

			if ( text.node() )
				textPosition.push( { x: text.attr( &quot;x&quot; ), y: text.attr( &quot;y&quot; ), text: IntersectionSet[key].list.size() } );
		}

		if ( textPosition.length &gt; 0 ){
			context.font = &quot;15px Open San&quot;;
			for ( i = 0; i &lt; textPosition.length; i++ ){
				var obj = textPosition[i];
				context.fillText(obj.text, obj.x, obj.y);
			}
		}

		//add back the title
		textPosition = [];
		for ( var i = 1; i &lt;= 7; i++ ) {
			var text = d3.select( &quot;#titleText&quot; + i )
			if ( text.node() )
				textPosition.push( { x: text.attr( &quot;x&quot; ), y: text.attr( &quot;y&quot; ), text: nameList[ i - 1 ] } );
		}

		if ( textPosition.length &gt; 0 ){
			context.font = &quot;15px Open San&quot;;
			for ( i = 0; i &lt; textPosition.length; i++ ){
				context.fillStyle = predefineColor[ i + 1 ];
				var obj = textPosition[i];
				context.fillText(obj.text, obj.x, obj.y);
			}
		}

		var canvasdata = canvas.node().toDataURL(&quot;image/png&quot;);

		var pngimg = '&lt;img src=&quot;'+canvasdata+'&quot;&gt;'; 

		//append &lt;a&gt; element on the html
		var a = document.createElement(&quot;a&quot;);
		a.id = &quot;for-download-png&quot;
		a.download = &quot;Venn.png&quot;;
		a.href = canvasdata;
		a.click();

		//remove the &lt;a&gt;
		d3.select( &quot;#for-download-png&quot; ).remove()
		canvas.remove();
	}
},</code></pre>
          <section id="saveLastRequireSets">
            <h1>saveLastRequireSets</h1>
            <h5 class="subheader"></h5>
            <p>
              <div class="label label-info radius ctx-type">method</div><span>saveLastRequireSets()</span>
            </p>
          </section>
          <div class="description"><p>Save last required Set if there is any. User can make requirement<br />by clicking on the Venn digram or via provide function getRequiredList()</p> </div>
          <pre><code class="language-javascript">saveLastRequireSets: function () {

	var key = this._getlastRequireSet();

	var intersect = this._getIntersectSets();
	var combination = intersect[ key ].combination;
	var listName = this._getIntersectSetsName(combination);
	var textToWrite = listName + &quot;:\n&quot; + intersect[ key ].list.array().join( &quot;\n&quot; );
	
	this._savefile( listName,  textToWrite )

},</code></pre>
          <section id="saveAllSets">
            <h1>saveAllSets</h1>
            <h5 class="subheader"></h5>
            <p>
              <div class="label label-info radius ctx-type">method</div><span>saveAllSets()</span>
            </p>
          </section>
          <div class="description"><p>Save all set including all sets and their intersect combination.</p> </div>
          <pre><code class="language-javascript">saveAllSets: function () {
	var intersect = this._getIntersectSets();
	var textToWrite = &quot;&quot;;
	var combination, listName;

	for ( key in intersect ) {
		combination = intersect[ key ].combination;
		listName = this._getIntersectSetsName(combination);
		textToWrite += listName + &quot;:\n&quot; + intersect[ key ].list.array().join( &quot;\n&quot; );
		textToWrite += &quot;\n\n&quot;
	}
	
	this._savefile( &quot;All Lists&quot;,  textToWrite )

},</code></pre>
          <section id="setClickCallback">
            <h1>setClickCallback</h1>
            <h5 class="subheader"></h5>
            <p>
              <div class="label label-info radius ctx-type">method</div><span>setClickCallback()</span>
            </p>
          </section>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th style="width:20%">Option name</th>
                <th style="width:20%">Type</th>
                <th>Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>callback</td>
                <td>Function</td>
                <td>&lt;p&gt;click callback function&lt;/p&gt;</td>
              </tr>
            </tbody>
          </table>
          <div class="description"><p>Custom click callback function for Venn diagram. In the other words,<br />define behavior after clicking on the Venn diagram. This function<br />will receive an object after clikcing on a specific set in the Venn diagram.<br />This is the structure of the object: { title, list, combination }.<br />&quot;title&quot; (String) is the name of the set, &quot;list&quot; (Array) contain all elements<br />of the set, &quot;combination&quot; (Array) is component index of the set.<br />For example, if user click on &quot;A intersect B&quot; area, where A is List 1 and B is List 2<br />Then title is &quot;A intersect B&quot;<br />&quot;list&quot; contain all elements of &quot;A intersect B&quot;<br />combination is an array contain two element: [ 1, 2 ]</p> </div>
          <pre><code class="language-javascript">setClickCallback: function ( callback ){
	this._setclickChartCallback( callback );
},</code></pre>
          <section id="getNumberOfSets">
            <h1>getNumberOfSets</h1>
            <h5 class="subheader"></h5>
            <p>
              <div class="label label-info radius ctx-type">method</div><span>getNumberOfSets()</span> -><span>Integer</span>
            </p>
          </section>
          <div class="description"><p>Number of sets in the Venn diagram right now</p> </div>
          <pre><code class="language-javascript">getNumberOfSets: function () {
	return this._listSets.length;
},</code></pre>
          <section id="getMaxVennSets">
            <h1>getMaxVennSets</h1>
            <h5 class="subheader"></h5>
            <p>
              <div class="label label-info radius ctx-type">method</div><span>getMaxVennSets()</span> -><span>Integer</span>
            </p>
          </section>
          <div class="description"><p>Get the upper limit number of sets</p> </div>
          <pre><code class="language-javascript">getMaxVennSets: function () {
	return this._N;
},</code></pre>
          <section id="switchToAutoMode">
            <h1>switchToAutoMode</h1>
            <h5 class="subheader"></h5>
            <p>
              <div class="label label-info radius ctx-type">method</div><span>switchToAutoMode()</span>
            </p>
          </section>
          <div class="description"><p>Switch to Automatic Venn diagram Layout.<br />When there are more than 5 sets,<br />the automatic layout will generate Euler diagram instead.</p> </div>
          <pre><code class="language-javascript">switchToAutoMode: function () {
	this.autoLayout = true;
	this._updateGraph();
},</code></pre>
          <section id="switchToPredfinedMode">
            <h1>switchToPredfinedMode</h1>
            <h5 class="subheader"></h5>
            <p>
              <div class="label label-info radius ctx-type">method</div><span>switchToPredfinedMode()</span>
            </p>
          </section>
          <div class="description"><p>Switch to predefined Venn diagram Layout.<br />When there are more than 6 sets,<br />the predefined layout will generate Euler diagram instead.</p> </div>
          <pre><code class="language-javascript">switchToPredfinedMode: function () {
	this.autoLayout = false;
	this._updateGraph();
},</code></pre>
          <section id="updateListName">
            <h1>updateListName</h1>
            <h5 class="subheader"></h5>
            <p>
              <div class="label label-info radius ctx-type">method</div><span>updateListName()</span>
            </p>
          </section>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th style="width:20%">Option name</th>
                <th style="width:20%">Type</th>
                <th>Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>index</td>
                <td>Number</td>
                <td>&lt;p&gt;the set need to be modified name&lt;/p&gt;</td>
              </tr>
              <tr>
                <td>name</td>
                <td>String</td>
                <td>&lt;p&gt;new name for the set&lt;/p&gt;</td>
              </tr>
            </tbody>
          </table>
          <div class="description"><p>Update the title of specific set.<br />Remind that the index should start from 1 instead of 0<br />For example, if you want to set the first set name &quot;movies&quot;,<br />then you should index = 1, name = &quot;movies&quot;</p> </div>
          <pre><code class="language-javascript">updateListName: function ( index, name ){

	if ( this._listSets[index] )
		this._updateName( index, name );

},</code></pre>
          <section id="getRequiredList">
            <h1>getRequiredList</h1>
            <h5 class="subheader"></h5>
            <p>
              <div class="label label-info radius ctx-type">method</div><span>getRequiredList()</span> -><span>Object</span>
            </p>
          </section>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th style="width:20%">Option name</th>
                <th style="width:20%">Type</th>
                <th>Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>requireList</td>
                <td>Array</td>
                <td>&lt;p&gt;a list of required set index&lt;/p&gt;</td>
              </tr>
            </tbody>
          </table>
          <div class="description"><p>Get a specific set. If user want to get Set 1, Set 2, and Set 3 interect,<br />input an Array = [ 1, 2, 3 ]. If user only want Set 2, then input an Array<br />only contain one element [ 2 ].<br />This function return an object { title, list }:<br />&quot;title&quot; is the name of the required set<br />&quot;list&quot; contains all the element of the required set.<br />Please remain that title is the name of the set.<br />If user require Set 1 and Set 2 intersect where Set 1 names &quot;A&quot; and Set 2 names &quot;B&quot;,<br />then &quot;title&quot; is &quot; A intersect B &quot;.</p> </div>
          <pre><code class="language-javascript">getRequiredList: function( requireList ){
	
	if ( requireList instanceof Array ) {
		if ( requireList.length != 0 &amp;&amp; requireList.length &lt;= 7 ) {

			requireList.sort();
			var requireKey = requireList[0];

			for ( i = 1; i &lt; requireList.length; i++ ){
				//generate 1in2in......
				requireKey += &quot;in&quot; + requireList[i];
			}

			var intersectSets = this._getIntersectSets()

			if ( intersectSets ){
				if ( intersectSets[requireKey] ) {
					this._updatelastRequireSet( requireKey );
					var name = this._getIntersectSetsName( intersectSets[requireKey].combination )
					return  { title: name, list: intersectSets[requireKey].list.array()};
				}
			}
		}
	}

},</code></pre>
          <section id="getRequiredListByName">
            <h1>getRequiredListByName</h1>
            <h5 class="subheader"></h5>
            <p>
              <div class="label label-info radius ctx-type">method</div><span>getRequiredListByName()</span> -><span>Object</span>
            </p>
          </section>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th style="width:20%">Option name</th>
                <th style="width:20%">Type</th>
                <th>Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>requireList</td>
                <td>Array</td>
                <td>&lt;p&gt;a list of required set name&lt;/p&gt;</td>
              </tr>
            </tbody>
          </table>
          <div class="description"><p>Get a specific set by name. If user want to get<br />Set 1(name: &quot;A&quot;), Set 2(name: &quot;B&quot;), and Set 3(name: &quot;C&quot;) interect,<br />input an Array = [ &quot;A&quot;, &quot;B&quot;, &quot;C&quot; ]. If user only want Set 2(name: B), then input an Array<br />only contain one element [ &quot;B&quot; ].<br />This function return an object { title, list }:<br />&quot;title&quot; is the name of the required set<br />&quot;list&quot; contains all the element of the required set.<br />Please remain that title is the name of the set.</p> </div>
          <pre><code class="language-javascript">getRequiredListByName: function( requireList ){

	if ( requireList instanceof Array ) {
		if ( requireList.length != 0 &amp;&amp; requireList.length &lt;= 7 ) {

			var requirement = [];

			for ( i = 0; i &lt; requireList.length; i++ )
				for ( j = 0; j &lt; this._listSets.length; j++ )
					if ( this._listSets[j].name == requireList[i] )
						requirement.push( j );

			if ( requirement.length &gt; 0 )
				return getRequiredList( requirement );
		}
	}

},</code></pre>
          <section id="getAllIntersectSets">
            <h1>getAllIntersectSets</h1>
            <h5 class="subheader"></h5>
            <p>
              <div class="label label-info radius ctx-type">method</div><span>getAllIntersectSets()</span> -><span>Array</span>
            </p>
          </section>
          <div class="description"><p>Get all sets including their combinations.<br />This function return an array of object { title, list }:<br />&quot;title&quot; is the name of set.<br />&quot;list&quot; contains all the element of set.<br />Please remain that title is the name of the set.</p> </div>
          <pre><code class="language-javascript">getAllIntersectSets: function(){
	var ans = [];
	var intersectList = this._getIntersectSets();

	for ( key in intersectList ) {
		var combination = intersectList[key].combination;
		var name = this._getIntersectSetsName( combination )

		ans.push( { title: name, intersectList: intersectList[key].list.array() } )
	}

	return ans;
},</code></pre>
          <section id="updateList">
            <h1>updateList</h1>
            <h5 class="subheader"></h5>
            <p>
              <div class="label label-info radius ctx-type">method</div><span>updateList()</span>
            </p>
          </section>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th style="width:20%">Option name</th>
                <th style="width:20%">Type</th>
                <th>Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>index</td>
                <td>Number</td>
                <td>&lt;p&gt;index of the set need to be modified&lt;/p&gt;</td>
              </tr>
              <tr>
                <td>name</td>
                <td>String</td>
                <td>&lt;p&gt;new name for the set. If null, keep the name&lt;/p&gt;</td>
              </tr>
              <tr>
                <td>list</td>
                <td>Array</td>
                <td>&lt;p&gt;a list of element replaced the desired set&lt;/p&gt;</td>
              </tr>
            </tbody>
          </table>
          <div class="description"><p>Update the whole set.<br />This function provide an interface to update Set content.<br />If user want to update List 1 name to &quot;A&quot;, and element = [ &quot;Monday&quot;, &quot;Tuesday&quot; ],<br />then index = 1, name = &quot;A&quot;, list = [ &quot;Monday&quot;, &quot;Tuesday&quot; ].<br />If user only want to update the set content, then name = null.<br />Remind that parameter list will completely replace the exist content in the set.</p> </div>
          <pre><code class="language-javascript">updateList: function ( index, name, list ){

	if ( this._listSets[index] ) {
		
		if ( list.length == 1 &amp;&amp; list[0] == &quot;&quot;  )
			this._listSets[index].list = new sets.Set();
		else
			this._listSets[index].list = new sets.Set( list );

		if ( name )
			this._updateName( index, name );

		if ( list.length == 0 || (list.length == 1 &amp;&amp; list[0] == &quot;&quot; ) ) {
			if ( index + 1 == this._listSets.length ) {

				for ( var i = index; i &gt;= 0; i-- ){
					if ( this._listSets[i].list.size() == 0 || (this._listSets[i].list.size() == 1 &amp;&amp; this._listSets[i].list.array()[0] == &quot;&quot; ) )
						this._listSets.pop();
					else
						break;
				}
				var ans = this._generateAllIntersectSets( );
				
				this._updateIntersectSets( ans );
				this._updateGraph();
				return true;
			}
		}

		//TODO: find a faster way to update existing list.
		var ans = this._generateAllIntersectSets( );
		
		this._updateIntersectSets( ans );
		this._updateText();

		return true;
	}

	return false;
},</code></pre>
          <section id="addList">
            <h1>addList</h1>
            <h5 class="subheader"></h5>
            <p>
              <div class="label label-info radius ctx-type">method</div><span>addList()</span>
            </p>
          </section>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th style="width:20%">Option name</th>
                <th style="width:20%">Type</th>
                <th>Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>name</td>
                <td>String</td>
                <td>&lt;p&gt;name of the new set&lt;/p&gt;</td>
              </tr>
              <tr>
                <td>list</td>
                <td>Array</td>
                <td>&lt;p&gt;list of element of the new set&lt;/p&gt;</td>
              </tr>
            </tbody>
          </table>
          <div class="description"><p>add one more set to the Venn diagram if possible.<br />If the the Venn diagram is already full, then nothing happen.</p> </div>
          <pre><code class="language-javascript">addList: function ( name, list ) {
	if ( this._listSets.length  == this._N )
		return;

	if ( list.length == 1 &amp;&amp; list[0] == &quot;&quot; )
		this._listSets.push( { name: name, list: new sets.Set() } );
	else
		this._listSets.push( { name: name, list: new sets.Set( list ) } );
	
	this._updateName( this._listSets.length - 1, name )
	var ans = this._generateAllIntersectSets();
	
	this._updateIntersectSets( ans );
	this._updateGraph();

},</code></pre>
          <section id="readJSON">
            <h1>readJSON</h1>
            <h5 class="subheader"></h5>
            <p>
              <div class="label label-info radius ctx-type">method</div><span>readJSON()</span>
            </p>
          </section>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th style="width:20%">Option name</th>
                <th style="width:20%">Type</th>
                <th>Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>input</td>
                <td>String</td>
                <td>&lt;p&gt;json text contain all the sets and corresponding name&lt;/p&gt;</td>
              </tr>
            </tbody>
          </table>
          <div class="description"><p>parse and JSON to sets.<br />Here is the structure of input:<br />&quot;{ &quot;A&quot;: [ 1, 2, 3, 4 ],<br />  &quot;B&quot;: [ 2, 3, 4, 7 ] }&quot;<br />key will be the name of the set</p> </div>
          <pre><code class="language-javascript">readJSON: function( text ) {
	
	try {
		var data = JSON.parse(text);

		this.updateAllList( data );
    }
    catch ( e ){
    	alert( &quot;Wrong JSON format.&quot; );
    }
},</code></pre>
          <section id="updateAllList">
            <h1>updateAllList</h1>
            <h5 class="subheader"></h5>
            <p>
              <div class="label label-info radius ctx-type">method</div><span>updateAllList()</span>
            </p>
          </section>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th style="width:20%">Option name</th>
                <th style="width:20%">Type</th>
                <th>Description</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>data</td>
                <td>Object</td>
                <td>&lt;p&gt;an input object contain all the sets and coreponding name&lt;/p&gt;</td>
              </tr>
            </tbody>
          </table>
          <div class="description"><p>Replace all list with the given data<br />Here is the structure of input:<br />{ &quot;A&quot;: [ 1, 2, 3, 4 ],<br />  &quot;B&quot;: [ 2, 3, 4, 7 ] }<br />key will be the name of the set.<br />Compare to readJSON(), this function accept object.</p> </div>
          <pre><code class="language-javascript">updateAllList: function ( data ) {
	
	this._listSets = [];
	
	var ans = {};
	var counter = 0;

	for ( key in data ) {
		if ( counter == this._N ) {
			break;
		}
		this._listSets[ counter ] = {  name: key , list: new sets.Set(data[key])};
		this._updateName( counter, key );
		counter++;
	}

	ans = this._generateAllIntersectSets( );
	
	this._updateIntersectSets( ans );
	this._updateGraph();

}
}

exports.BioJSVenn = function( target, lists, clickCallback ) {

if ( !target )
	return;

var generateCombination = function ( start, end ){
	var ans = [];

	for ( var i = end; i &gt;= start; i-- ){
		var result = [];
		result.push( [ i ] );

		for ( var j = 0; j &lt; ans.length; j++ )
			for ( var k = 0; k &lt; ans[j].length; k++ )
				result.push( ans[j][k].concat( [i] ) );

		ans.push( result );
	}

	return ans;
}

var mouseClickCall = function ( id ) {


	var combination = IntersectionSet[ id ].combination;
	var text = &quot;&quot;;
	var arr = [];

	text = getNameByCombination( combination );

	lastRequireSet = id;

	if ( IntersectionSet[ id ] )
		if ( IntersectionSet[ id ].list.size() &gt; 0 )
			arr =	IntersectionSet[ id ].list.array() ;

	if ( clickChartCallback &amp;&amp; clickChartCallback instanceof Function )
		clickChartCallback( { title: text, list: arr, combination: combination  } )
}

//call this when mouse over event is triggered
var mouseOverCall = function ( target, id ){

	d3.select(target).transition()
		.style( &quot;fill-opacity&quot;,  function() {
			if ( typeof id == 'string' || id instanceof String)
				return 0.55;
			else 
				return selectedShapeFillOpacity;
			}
		)
		.style( &quot;stroke-opacity&quot;, 0 );

	var combination = IntersectionSet[ id ].combination;

	d3.select( &quot;#text&quot; + id ).transition()
		.style( &quot;fill&quot;, &quot;white&quot; );

	if ( typeof id == 'string' || id instanceof String) {

		var selectedSet = IntersectionSet[ id ].list;
		var intersectSetSize = selectedSet.size();

		if ( intersectSetSize != 0 ) {

			for ( i = 0; i &lt; combination.length; i++ ){
				var targetSize = IntersectionSet[ combination[i].toString() ].list.size()

				var ratio = intersectSetSize / targetSize;

				d3.select( &quot;#shape&quot; + combination[i] ).transition()
					.style( &quot;fill-opacity&quot;,  function() {

						var temp = (selectedShapeFillOpacity - unselectedShapeFillOpacity) * ratio;

						return unselectedShapeFillOpacity + temp;
					} )
			}
		}
	}

	//Update the tooltip position and value
	d3.select(&quot;#vennToolTip&quot;).transition()
	.style(&quot;left&quot;, (d3.event.pageX - 250) + &quot;px&quot;)
	.style(&quot;top&quot;, (d3.event.pageY - 5) + &quot;px&quot;)
	.style(&quot;position&quot;, &quot;absolute&quot;)
	.style(&quot;opacity&quot;, 0.6 )
	.style(&quot;z-index&quot;, 9)

	d3.select(&quot;#vennToolTipTitle&quot;)
		.text( function (d) { 

		return getNameByCombination( combination ) + &quot;:&quot;;
	});

	d3.select( &quot;#vennToolTipListSize&quot; )
		.text( &quot; size = &quot; + IntersectionSet[ id ].list.size() )

	d3.select( &quot;#vennToolTipList&quot; )
		.text( function (d) {
			var text = &quot;&quot;;

			if ( IntersectionSet[ id ] )
				text += IntersectionSet[ id ].list.array().join(&quot; | &quot;);
			
			return text;
		} );
};

//Get set nambe by a list of combination/
//For example, if List 1 intersect List 2 name is needed,
//then combination = [ 1, 2 ]
//@param {Array} combination Array of set index
//@return {String} nume of the required set
var getNameByCombination = function( combination ) {
	var text =  nameList[ combination[0] - 1 ];

	for ( i = 1; i &lt; combination.length; i++ ){
		
		if ( text != &quot;&quot; )
			text += &quot; in &quot; + nameList[ combination[i] - 1 ];
		else
			text += nameList[ combination[i] - 1 ];
	}

	return text;
}

//call this when mouse out event is triggered
var mouseOutCall = function (target, id) {
	d3.select(target).transition()
		.style(&quot;fill-opacity&quot;, function () {
			if ( typeof id == 'string' || id instanceof String)
				return 0;
	 		else 
	 			return unselectedShapeFillOpacity;
	  	})
	 	.style(&quot;stroke-opacity&quot;, unselectedStrokeFillOpacity );
       
	var combination = IntersectionSet[ id ].combination;

	d3.select( &quot;#text&quot; + id ).transition()
		.style( &quot;fill&quot;, &quot;black&quot; );

	if ( typeof id == 'string' || id instanceof String) {

		var selectedSet = IntersectionSet[ id ].list;
		var intersectSetSize = selectedSet.size();

		if ( intersectSetSize != 0 ) {

			for ( i = 0; i &lt; combination.length; i++ ){
				d3.select( &quot;#shape&quot; + combination[i] ).transition()
					.style( &quot;fill-opacity&quot;, unselectedShapeFillOpacity )
					.attr( &quot;x&quot;, -1 );
			}
		}
	}

       //Hide the tooltip
	d3.select(&quot;#vennToolTip&quot;).transition().style(&quot;opacity&quot;, 0 ); 
};

var mouseMoveCall = function (traget) {
	d3.select(&quot;#vennToolTip&quot;)
		.style(&quot;left&quot;, (d3.event.pageX - 250) + &quot;px&quot;)
		.style(&quot;top&quot;, (d3.event.pageY - 5) + &quot;px&quot;)	
};

var drawEllipse = function ( jsonData ){

	if ( jsonData.length == 0 )
		return;

	var targetTransform = jsonData.length - 1;

	var transformGroup = svg.append(&quot;g&quot;)
							.attr( &quot;transform&quot;, &quot;scale(&quot; + transform[ targetTransform ].scale + &quot;) &quot;
										+ &quot;translate(&quot; + transform[ targetTransform ].x + &quot;, &quot;
										+ transform[ targetTransform ].y + &quot;)&quot; )

	addWhiteBackground( transformGroup );

	var defs = transformGroup.append( &quot;defs&quot; )
							.selectAll(&quot;_&quot;)
							.data(jsonData)
							.enter()
							.append(&quot;g&quot;);

	//use for clipping later.
	defs.append( &quot;clipPath&quot; )
		.attr( &quot;id&quot;, function (d) { return &quot;clip&quot; + d.id } )
		.append( &quot;ellipse&quot; )
		.attr(&quot;transform&quot;, function (d) { return &quot;rotate(&quot; + d.rotate + &quot;, &quot; + d.cx + &quot;, &quot; + d.cy + &quot;) &quot; })
		.attr(&quot;cx&quot;, function (d) { return d.cx} ).attr(&quot;cy&quot;, function (d) { return d.cy } )
		.attr(&quot;rx&quot;, function (d) { return d.rx} ).attr(&quot;ry&quot;, function (d) { return d.ry } );

	// This part is used to create a fake Stroke for the clipping. However, this part is not longer used.
	//defs.append( &quot;clipPath&quot; )
	//	.attr( &quot;id&quot;, function (d) { return &quot;clipL&quot; + d.id } )
	//	.append( &quot;ellipse&quot; )
	//	.attr(&quot;transform&quot;, function (d) { return &quot;rotate(&quot; + d.rotate + &quot;, &quot; + d.cx + &quot;, &quot; + d.cy + &quot;) &quot; })
	//	.attr(&quot;cx&quot;, function (d) { return d.cx} ).attr(&quot;cy&quot;, function (d) { return d.cy } )
	//	.attr(&quot;rx&quot;, function (d) { return d.rx + StrokeWidth} ).attr(&quot;ry&quot;, function (d) { return d.ry + StrokeWidth} );
	//
	var shapeGroup = transformGroup.selectAll(&quot;_&quot;)
								.data(jsonData)
								.enter()
								.append( &quot;g&quot; );

	shapeGroup.append( &quot;ellipse&quot; )
			.attr( &quot;id&quot;, function (d) { return &quot;shape&quot; + d.id } )
			.attr(&quot;transform&quot;, function (d) { return &quot;rotate(&quot; + d.rotate + &quot;, &quot; + d.cx + &quot;, &quot; + d.cy + &quot;) &quot; })
			.attr(&quot;cx&quot;, function (d) { return d.cx} ).attr(&quot;cy&quot;, function (d) { return d.cy } )
			.attr(&quot;rx&quot;, function (d) { return d.rx} ).attr(&quot;ry&quot;, function (d) { return d.ry } )
			.style(&quot;fill&quot;, function(d) { return predefineColor[d.id] })
			.style(&quot;fill-opacity&quot;, unselectedShapeFillOpacity )
			.style(&quot;stroke-opacity&quot;, unselectedStrokeFillOpacity )
			.style(&quot;stroke&quot;, predefineStrokeColor )
			.style(&quot;stroke-width&quot;, StrokeWidth )
			.on(&quot;mouseover&quot;, function (d) { mouseOverCall(this, d.id); })
			.on(&quot;mouseout&quot;, function (d)  { mouseOutCall(this, d.id); })
			.on(&quot;mousemove&quot;, function (d) { mouseMoveCall(this); })
			.on(&quot;click&quot;, function (d) { mouseClickCall( d.id ) } );

	shapeGroup.append( &quot;text&quot; )
			.attr( &quot;id&quot;, function (d) { return &quot;text&quot; + d.id } )
			.text( function (d){
				if ( !IntersectionSet[ d.id.toString() ] )
					return 0;
				else
					return IntersectionSet[ d.id.toString() ].list.size() 
			} )
			.attr(&quot;x&quot;, function (d) { return d.textX } ).attr(&quot;y&quot;, function(d){ return d.textY });

	//combinationList -&gt; 	4
	//					3 4,3
	//					2 4,2 3,2 4,3,2
	//					1 4,1 4,3,1 2,1 4,2,1  
	//

	drawClip( combinationList, transformGroup );

	if ( jsonData.length &gt; 1 )
		putPredefinedTextLabel( jsonData.length, transformGroup )
	    
};

var drawPath = function ( jsonData ){

	if ( jsonData.length == 0 )
		return;

	//  How to seperate Polygon and intersect?
	//	Take a look at the predefine JSON data at the very begining.
	//	For interesct area, the id is String. (e.g. &quot;1_2&quot;)
	//
	//Here is how to check is the data for intersect or for shape.
	//if ( typeof jsonData[1].id == 'string' || jsonData.id instanceof String) {
	//
	//}

	var targetTransform = jsonData.length - 1;

	var transformGroup = svg.append(&quot;g&quot;)
							.attr( &quot;transform&quot;, &quot;scale(&quot; + transform[ targetTransform ].scale + &quot;) &quot;
										+ &quot;translate(&quot; + transform[ targetTransform ].x + &quot;, &quot;
										+ transform[ targetTransform ].y + &quot;)&quot; )

	addWhiteBackground( transformGroup );

	var defs = transformGroup.append( &quot;defs&quot; )
							.selectAll(&quot;_&quot;)
							.data(jsonData)
							.enter()
							.append(&quot;g&quot;);

	defs.append( &quot;clipPath&quot; )
		.attr( &quot;id&quot;, function (d) { return &quot;clip&quot; + d.id } )
		.append(&quot;path&quot;)
		.attr( &quot;d&quot;, function (d){ return d.d } )

	var shapeGroup = transformGroup.selectAll(&quot;_&quot;)
								.data(jsonData)
								.enter()
								.append( &quot;g&quot; );


	shapeGroup.attr( &quot;id&quot;, function (d) { return &quot;shape&quot; + d.id } )
			.append(&quot;path&quot;)
			.attr( &quot;id&quot;, function (d){ return d.id } )
			.attr( &quot;d&quot;, function (d){ return d.d } )
			.attr( &quot;fill&quot;, function (d) { return predefineColor[d.id]; } )
			.style(&quot;fill-opacity&quot;, function (d) { return unselectedShapeFillOpacity; } )
			.style(&quot;stroke-opacity&quot;, unselectedStrokeFillOpacity )
			.style(&quot;stroke&quot;, function (d) { return predefineStrokeColor; } )
			.style(&quot;stroke-width&quot;, StrokeWidth )
			.on(&quot;mouseover&quot;, function (d) {  mouseOverCall(this, d.id); })
			.on(&quot;mouseout&quot;, function (d) {  mouseOutCall(this, d.id); })
			.on(&quot;mousemove&quot;, function (d) { mouseMoveCall(this); })
			.on(&quot;click&quot;, function (d) { mouseClickCall( d.id ) } );

	shapeGroup.append( &quot;text&quot; )
		.attr( &quot;id&quot;, function (d){ return &quot;text&quot; + d.id } )
		.text( function (d){
			if ( !IntersectionSet[ d.id.toString() ] )
				return 0;
			else
				return IntersectionSet[ d.id.toString() ].list.size() } )
		.attr(&quot;x&quot;, function (d) { return d.textX } ).attr(&quot;y&quot;, function(d){ return d.textY });

	drawClip( combinationList, transformGroup );

	if ( jsonData.length &gt; 1 )
		putPredefinedTextLabel( jsonData.length, transformGroup )

};

//Put predefined text label on the graph.
//This method called by drawEplise() and drawPath()
//@param {Number} numberOfSets number of sets have be drawn
//@param {Object} drawSVG on which svg object should put text label
var putPredefinedTextLabel = function( numberOfSets, drawSVG ){
	drawSVG.selectAll(&quot;_&quot;)
			.data( predefineIntersectText[numberOfSets] )
			.enter()
			.append( &quot;g&quot; )
			.append( &quot;text&quot; )
			.attr( &quot;id&quot;, function (d) { return &quot;text&quot; + d.id } )
			.attr( &quot;x&quot;, function (d) { return d.textX } ).attr(&quot;y&quot;, function(d){ return d.textY })
			.text( function (d){
				if ( !IntersectionSet[ d.id.toString() ] )
					return 0;
				else
					return IntersectionSet[ d.id.toString() ].list.size() } );
}

//automatically generated the Venn digram
//@param {Number} num number of set want to be generated
var drawVenn = function (num) {

	var toRadian = function ( degree ) {
		return degree * Math.PI / 180;
	}

	var rotateAngle = 360 / num;

	var x = 300, y = 320;
	var rx = 200, ry = 110;
	var startAngle = rotateAngle;

	var magnitudeA = 55;
	var magnitudeB = 18;

	var directionA = startAngle + 180;			//in degree
	var directionB = rotateAngle;	//in degree
	
	var nextX = x, nextY = y;

	var graphData = [], textData = [], titleData = [];

	for ( var i = 0; i &lt; num; i++ ){
		nextX += magnitudeA * Math.cos( toRadian(directionA + rotateAngle * i) )
		nextY += magnitudeA * Math.sin( toRadian(directionA + rotateAngle * i) )
		
		var toBDirection = toRadian(directionB + rotateAngle * i);
		graphData.push( { id: i + 1, rotate: startAngle + rotateAngle * i, rx: rx, ry: ry,
						cx: nextX + magnitudeB * Math.cos( toBDirection ),
						cy: nextY + magnitudeB * Math.sin( toBDirection ) } )
		textData.push( { id: i + 1, 
						x: nextX - ( magnitudeB + rx * 0.71 ) * Math.cos( toBDirection ),
						y: nextY - ( magnitudeB + rx * 0.71 ) * Math.sin( toBDirection ) } )
		titleData.push( { id: i + 1, 
						x: nextX - ( magnitudeB + rx ) * Math.cos( toBDirection ),
						y: nextY - ( magnitudeB + rx ) * Math.sin( toBDirection ) } )			
		nextX += magnitudeB * Math.cos( toBDirection )
		nextY += magnitudeB * Math.sin( toBDirection )
	}

	var transformGroup = svg.append(&quot;g&quot;)
							.attr( &quot;transform&quot;, &quot;scale(&quot; + transform[num - 1].scale + &quot;) &quot;
									+ &quot;translate(&quot; + transform[num - 1].x + &quot;, &quot;
									+ transform[num - 1].y + &quot;)&quot; )

	addWhiteBackground( transformGroup );

	var defs = transformGroup.append( &quot;defs&quot; )
							.selectAll(&quot;_&quot;)
							.data(graphData)
							.enter()
							.append(&quot;g&quot;);

	defs.append( &quot;clipPath&quot; )
		.attr( &quot;id&quot;, function (d) { return &quot;clip&quot; + d.id } )
		.append( &quot;ellipse&quot; )
		.attr(&quot;transform&quot;, function (d) { return &quot;rotate(&quot; + d.rotate + &quot;, &quot; + d.cx + &quot;, &quot; + d.cy + &quot;) &quot; })
		.attr(&quot;cx&quot;, function (d) { return d.cx} ).attr(&quot;cy&quot;, function (d) { return d.cy } )
		.attr(&quot;rx&quot;, function (d) { return d.rx} ).attr(&quot;ry&quot;, function (d) { return d.ry } );


	var shapeGroup = transformGroup.selectAll(&quot;_&quot;)
								.data(graphData)
								.enter()
								.append( &quot;g&quot; );

	shapeGroup.append( &quot;ellipse&quot; )
		.attr( &quot;id&quot;, function (d) { return &quot;shape&quot; + d.id } )
		.attr(&quot;transform&quot;, function (d) { return &quot;rotate(&quot; + d.rotate + &quot;, &quot; + d.cx + &quot;, &quot; + d.cy + &quot;) &quot; })
		.attr(&quot;cx&quot;, function (d) { return d.cx} ).attr(&quot;cy&quot;, function (d) { return d.cy } )
		.attr(&quot;rx&quot;, function (d) { return d.rx} ).attr(&quot;ry&quot;, function (d) { return d.ry } )
		.style(&quot;fill&quot;, function (d) { return predefineColor[d.id] })
		.style(&quot;fill-opacity&quot;, unselectedShapeFillOpacity )
		.style(&quot;stroke-opacity&quot;, unselectedStrokeFillOpacity )
		.style(&quot;stroke&quot;, predefineStrokeColor )
		.style(&quot;stroke-width&quot;, StrokeWidth )
		.on(&quot;mouseover&quot;, function (d) { mouseOverCall(this, d.id); })
		.on(&quot;mouseout&quot;, function (d)  { mouseOutCall(this, d.id); })
		.on(&quot;mousemove&quot;, function (d) { mouseMoveCall(this); })
		.on(&quot;click&quot;, function (d) { mouseClickCall( d.id ) } );

	drawClip( combinationList, transformGroup );

	
	var textGroup = transformGroup.selectAll(&quot;_&quot;)
								.data(textData)
								.enter()
								.append( &quot;g&quot; );

	textGroup.append( &quot;text&quot; )
			.attr( &quot;id&quot;, function (d) { return &quot;text&quot; + d.id } )
			.attr( &quot;x&quot;, function (d) { return d.x } ).attr( &quot;y&quot;, function (d) { return d.y } )
			.text( function (d) {
				if ( !IntersectionSet[ d.id.toString() ] )
					return 0;
				else
					return IntersectionSet[ d.id.toString() ].list.size() 
			} )
	
	var titleGroup = transformGroup.selectAll(&quot;_&quot;)
							.data(titleData)
							.enter()
							.append( &quot;g&quot; );

	titleGroup.append( &quot;text&quot; )
			.attr( &quot;id&quot;, function (d) { return &quot;titleText&quot; + d.id } )
			.attr( &quot;x&quot;, function (d) { return d.x } ).attr( &quot;y&quot;, function (d) { return d.y } )
			.style( &quot;fill&quot;, function (d) { return predefineColor[ d.id ] } )
			.text( function (d) {
				return nameList[d.id - 1];
			} );</code></pre>
          <div class="description"><p>text lable for the size of intersect of all lists.</p> </div>
          <pre><code class="language-javascript">if ( num &gt;= 2 ) {
	var allIntersectText = &quot;1&quot;</code></pre>
          <div class="description"><p>generate 1in2in......</p> </div>
          <pre><code class="language-javascript">for ( i = 2; i &lt;= num; i++ )
	allIntersectText += &quot;in&quot; + i

transformGroup.append( &quot;text&quot; )
	.attr( &quot;id&quot;, &quot;text&quot; + allIntersectText )
	.attr( &quot;x&quot;, x ).attr( &quot;y&quot;, y - magnitudeB )
	.text( function () {
		if ( !IntersectionSet[ allIntersectText ] )
			return 0;
		else
			return IntersectionSet[ allIntersectText ].list.size();
	} )
		}
	}

	var drawClip = function ( combination, drawOn ) {

		var clip = function ( reuseID, group, clipID, i, j ){

for ( var k = 0; k &lt; combination[i][j].length; k++ ){
	group = group.append( &quot;g&quot; )
				.attr( &quot;clip-path&quot;, &quot;url(#&quot; + reuseID + combination[i][j][k] + &quot;)&quot; );
}

return group.append( &quot;rect&quot; )
			.attr( &quot;id&quot;, clipID )
			.attr( &quot;width&quot;, w ).attr( &quot;height&quot;, h )
			.attr( &quot;x&quot;, 0 ).attr( &quot;y&quot;, 0 )
		}

		for ( var i = 0; i &lt; combination.length; i++ ) {

for ( var j = 0; j &lt; combination[i].length; j++  ){
	if ( combination[i][j].length == 1 )
		continue;

	var targetID = combination[i][j].join(&quot;in&quot;);

	var group = drawOn.append( &quot;g&quot; )
					.attr( &quot;id&quot;, &quot;g&quot; + targetID )
					.style( &quot;fill-opacity&quot;, 0 );

	//clip( &quot;clipL&quot;, group, &quot;L&quot; + targetID ).style( &quot;fill&quot;, &quot;white&quot; );
	
	clip( &quot;clip&quot;, group, targetID, i, j ).on(&quot;mouseover&quot;, function () { mouseOverCall( &quot;#g&quot; + this.id , this.id ) } ) 
					.on(&quot;mouseout&quot;, function () {  mouseOutCall(&quot;#g&quot; + this.id, this.id); })
					.on(&quot;mousemove&quot;, function () { mouseMoveCall(this); })
					.on(&quot;click&quot;, function () { mouseClickCall( this.id ) } );
}
		}
	}

	var addWhiteBackground = function ( drawOn ) {
		drawOn.append( &quot;rect&quot; )
.attr( &quot;fill&quot;, &quot;white&quot; )
.attr(&quot;width&quot;, w).attr(&quot;height&quot;, h)
.attr( &quot;x&quot;, 0 ).attr( &quot;y&quot;, 0 );

	}

//redraw the whole graph immediately
	this._updateGraph = function () {

		svg.select(&quot;*&quot;).remove();

		if ( this._listSets.length == 0 )
return;

		if ( this.autoLayout ){
drawVenn( this._listSets.length );
		}
		else{
if ( this._listSets.length != 6 ) 
	drawEllipse( predefineShape[ this._listSets.length ] );
else
	drawPath( predefineShape[ this._listSets.length ] );
		}
	};

//comput all intersection set base on the sets provided by user
//@return {object} all intersection set
	this._generateAllIntersectSets = function ( ){

		var ans = {};

		for ( var i = this._listSets.length - 1; i &gt;= 0; i-- ) {
var result = {};

if ( this._listSets[i] )
	result[ (i + 1).toString() ] = this._listSets[i].list;


for ( var key in ans ){
	if ( this._listSets[ i ] ) 
		result[ ( i +1 ).toString() + &quot;in&quot; + key] = ans[key].intersection( this._listSets[ i ].list );
	
}
for (var attrname in result) { ans[attrname] = result[attrname]; }
		}

		combinationList.length = 0;
		combinationList = generateCombination( 1, this._listSets.length );

		return { list: ans };
	}; 

//
	this._updateIntersectSets = function ( ans ) {

		IntersectionSet = {};

		for ( key in ans.list ) {
IntersectionSet[ key ] = { list: ans.list[key], combination: [] }
		}

		for ( i = 0; i &lt; combinationList.length; i++ )
for ( j = 0; j &lt; combinationList[i].length; j++ )
	IntersectionSet[ combinationList[i][j].reverse().join(&quot;in&quot;) ][&quot;combination&quot;] = combinationList[i][j];
	};

//update a specific set name
	this._updateName = function ( i, name ){
		this._listSets[i].name = name;
		nameList[i] = name;

		var text = d3.select( &quot;#titleText&quot; + (i + 1) )

		if ( text.node() )
text.text( name );
	}

//update text when the intersection set is changed
	this._updateText = function () {
		
		if ( !IntersectionSet )
return;

		for ( key in IntersectionSet ){
var targetText = d3.select( &quot;#text&quot; + key );

if ( targetText[0][0] ){
	targetText.text( IntersectionSet[ key ].list.size() )
}
		}
	}

	this._getIntersectSets = function(){
		return IntersectionSet;
	}

	this._setclickChartCallback = function( x ){
		if ( x &amp;&amp; x instanceof Function )
clickChartCallback = x;
	}

	this._getIntersectSetsName = function ( combination ) {
		return getNameByCombination(combination);
	}

	this._updatelastRequireSet = function( key ){
		lastRequireSet = key;
	}

	this._getlastRequireSet = function () {
		return lastRequireSet;
	}

	this._savefile = function ( fileName ,textToWrite ) {
		var textFileAsBlob = new Blob([textToWrite], {type:'text/plain'});
		var fileNameToSaveAs = fileName;

		var downloadLink = document.createElement(&quot;a&quot;);
		downloadLink.download = fileNameToSaveAs;
		downloadLink.innerHTML = &quot;Download File&quot;;
		downloadLink.id = &quot;use-to-download-text-file&quot;

		if (window.webkitURL != null)
		{
// Chrome allows the link to be clicked
// without actually adding it to the DOM.
downloadLink.href = window.webkitURL.createObjectURL(textFileAsBlob);
		}
		else
		{
// Firefox requires the link to be added to the DOM
// before it can be clicked.
downloadLink.href = window.URL.createObjectURL(textFileAsBlob);
downloadLink.onclick = destroyClickedElement;
downloadLink.style.display = &quot;none&quot;;
document.body.appendChild(downloadLink);
		}

		downloadLink.click();
	}

	var lastRequireSet = &quot;&quot;;

	var clickChartCallback = &quot;&quot;;

	//predefine number of sets in Venn diagram.
	this._N = 7;
	//where the data of sets store.
	//_listSets[index]: where index is integer starting from 0
	//structure: { name: , list: }
	//name is used to store list name
	this._listSets = [];
	//store for the list name, once the name of list is updated.
	//( _listSets[i],name is updated. ) This one must also be updated.
	var nameList = [];
	//	intersect Sets structure:
	//	IntersectionSet[ key ]: key must be a string.
	//	for set 1, input &quot;1&quot;, for set 1in2 input &quot;1in2&quot;
	//	combination: list of this intersect set component.
	//			For example, 1in2 is intersect of 1 and 2.
	//			combination = [ 1, 2 ]
	//	list: the elements inside the intersect set.
 	var IntersectionSet;

	
	//	combinationList: this array is used for store all the combinations.
	//	For example, for a 3 sets venn diagram
	//	combinationList = [ [3], [2], [3, 2], [1], [3, 1], [2, 1], [3, 2, 1] ]
	
	var combinationList = [];
	var textPosition = [];

	var predefineColor = [];
	var predefineShape = [];
	var predefineIntersectText = [];

	var predefineStrokeColor = &quot;#259286&quot;;

	var selectedStrokeFillOpacity = 1;
	var unselectedStrokeFillOpacity = 0;

	var StrokeWidth = 2;

	var selectedShapeFillOpacity = 0.8;
	var unselectedShapeFillOpacity = 0.35;

	//store all graph transform arguments: translate and scale
	var transform = [];

	for ( i = 0; i &lt; this._N; i++ )
		transform.push( { x: 0, y: 0, scale: 1 } );

	//starting from this point is magic! Don't touch!
	//This maigc is used for predefined ellipsis and polygons.
	//special case for 1 to 3 sets Venn diagram
	//predefine circle
	var circleR = 110;	//control the radius of circles

	//One set venn diagram, only have one circle
	predefineShape[1] = [{ &quot;id&quot;: 1, &quot;cx&quot;: 230, &quot;cy&quot;: 306, &quot;rotate&quot;: 0, &quot;textX&quot;: 215, &quot;textY&quot;: 310 }];

	//two sets venn diagram, two circle
	predefineShape[2] = [{ &quot;id&quot;: 1, &quot;cx&quot;: 230, &quot;cy&quot;: 306, &quot;rotate&quot;: 0, &quot;textX&quot;: 215, &quot;textY&quot;: 310 },
				   { &quot;id&quot;: 2, &quot;cx&quot;: 370, &quot;cy&quot;: 306, &quot;rotate&quot;: 0, &quot;textX&quot;: 365, &quot;textY&quot;: 310 }];

	//three sets venn diagram
	predefineShape[3] = [{ &quot;id&quot;: 1, &quot;cx&quot;: 230, &quot;cy&quot;: 306, &quot;rotate&quot;: 0, &quot;textX&quot;: 215, &quot;textY&quot;: 310 },
				   { &quot;id&quot;: 2, &quot;cx&quot;: 370, &quot;cy&quot;: 306, &quot;rotate&quot;: 0, &quot;textX&quot;: 365, &quot;textY&quot;: 310 },
				   { &quot;id&quot;: 3, &quot;cx&quot;: 300, &quot;cy&quot;: 185, &quot;rotate&quot;: 0, &quot;textX&quot;: 290, &quot;textY&quot;: 180 }];

	for ( i = 1; i &lt;= 3; i++ ) {
		for ( j = 0; j &lt; i; j++ ) {
predefineShape[i][j].rx = circleR;
predefineShape[i][j].ry = circleR;
		}
	}

	//------------------ end of circle case -------------------------

	var ellipseRX = 200, ellipseRY = 110;
	//predefine ellipsis for 4 sets venn diagram
	predefineShape[4] = [	{ &quot;id&quot;: 1, &quot;cx&quot;: 196, &quot;cy&quot;: 246,&quot;rotate&quot;: 45,  &quot;textX&quot;: 70,  &quot;textY&quot;: 135 },
					{ &quot;id&quot;: 2, &quot;cx&quot;: 266, &quot;cy&quot;: 176,&quot;rotate&quot;: 45,  &quot;textX&quot;: 138, &quot;textY&quot;: 55 },
					{ &quot;id&quot;: 3, &quot;cx&quot;: 326, &quot;cy&quot;: 176,&quot;rotate&quot;: 135, &quot;textX&quot;: 435, &quot;textY&quot;: 58 },
					{ &quot;id&quot;: 4, &quot;cx&quot;: 396, &quot;cy&quot;: 246,&quot;rotate&quot;: 135, &quot;textX&quot;: 508, &quot;textY&quot;: 135 }];

	//predefine ellipsis for 5 sets venn diagram
	predefineShape[5] = [	{ &quot;id&quot;: 1, &quot;cx&quot;: 263, &quot;cy&quot;: 213,&quot;rotate&quot;: 90,  &quot;textX&quot;: 258, &quot;textY&quot;: 50  },
				{ &quot;id&quot;: 2, &quot;cx&quot;: 280, &quot;cy&quot;: 262,&quot;rotate&quot;: 162, &quot;textX&quot;: 438, &quot;textY&quot;: 216 },
				{ &quot;id&quot;: 3, &quot;cx&quot;: 241, &quot;cy&quot;: 292,&quot;rotate&quot;: 54,  &quot;textX&quot;: 330, &quot;textY&quot;: 433 },
				{ &quot;id&quot;: 4, &quot;cx&quot;: 199, &quot;cy&quot;: 266,&quot;rotate&quot;: 126, &quot;textX&quot;: 90,  &quot;textY&quot;: 409 },
				{ &quot;id&quot;: 5, &quot;cx&quot;: 212, &quot;cy&quot;: 216,&quot;rotate&quot;: 18,  &quot;textX&quot;: 42,  &quot;textY&quot;: 166 }];

	//predefine triangles for 6 sets venn diagram
	predefineShape[6] = [	{ &quot;id&quot;: 1, &quot;textX&quot;: 115, &quot;textY&quot;: 120, &quot;d&quot;: &quot;M  51.277  38.868 L 255.580 191.186 L 190.900 269.427 Z&quot; },
				{ &quot;id&quot;: 2, &quot;textX&quot;: 197, &quot;textY&quot;:  90, &quot;d&quot;: &quot;M 201.988  26.426 L 158.444 276.222 L 241.044 235.111 Z&quot; },
				{ &quot;id&quot;: 3, &quot;textX&quot;: 275, &quot;textY&quot;: 130, &quot;d&quot;: &quot;M 323.271  79.619 L 159.604 152.683 L 204.652 276.669 Z&quot; },
			  	{ &quot;id&quot;: 4, &quot;textX&quot;: 295, &quot;textY&quot;: 250, &quot;d&quot;: &quot;M 453.561 295.349 L 181.764 146.805 L 158.980 252.461 Z&quot; },
				{ &quot;id&quot;: 5, &quot;textX&quot;: 215, &quot;textY&quot;: 320, &quot;d&quot;: &quot;M 251.886 455.785 L 158.136 181.491 L 214.208  94.690 Z&quot; },
				{ &quot;id&quot;: 6, &quot;textX&quot;: 135, &quot;textY&quot;: 290, &quot;d&quot;: &quot;M  60.184 344.046 L 262.476 109.903 L 223.276 253.962 Z&quot; }];

	//predefine ellipsis for 7 sets venn diagram
	predefineShape[7] = [	{ &quot;id&quot;: 1, &quot;cx&quot;: 220, &quot;cy&quot;: 288,&quot;rotate&quot;: 0,   &quot;textX&quot;: 40,  &quot;textY&quot;: 228 },
				{ &quot;id&quot;: 2, &quot;cx&quot;: 216, &quot;cy&quot;: 246,&quot;rotate&quot;: 51,  &quot;textX&quot;: 96,  &quot;textY&quot;: 117 },
				{ &quot;id&quot;: 3, &quot;cx&quot;: 246, &quot;cy&quot;: 217,&quot;rotate&quot;: 102, &quot;textX&quot;: 273, &quot;textY&quot;: 49  },
				{ &quot;id&quot;: 4, &quot;cx&quot;: 289, &quot;cy&quot;: 222,&quot;rotate&quot;: 154, &quot;textX&quot;: 434, &quot;textY&quot;: 152 },
				{ &quot;id&quot;: 5, &quot;cx&quot;: 310, &quot;cy&quot;: 258,&quot;rotate&quot;: 25,  &quot;textX&quot;: 458, &quot;textY&quot;: 341 },
				{ &quot;id&quot;: 6, &quot;cx&quot;: 296, &quot;cy&quot;: 298,&quot;rotate&quot;: 77,  &quot;textX&quot;: 330, &quot;textY&quot;: 472 },
				{ &quot;id&quot;: 7, &quot;cx&quot;: 256, &quot;cy&quot;: 311,&quot;rotate&quot;: 135, &quot;textX&quot;: 132, &quot;textY&quot;: 440 }];

	for ( i = 4; i &lt;= this._N; i++ ) {
		//6 sets Venn diagram is a special case
		if ( i != 6 ) {
for ( j = 0; j &lt; i; j++ ){
	predefineShape[i][j].rx = ellipseRX;
	predefineShape[i][j].ry = ellipseRY;
}
		}
	}

	predefineIntersectText[2] = [ { &quot;id&quot;: &quot;1in2&quot;, &quot;textX&quot;: 290, &quot;textY&quot;: 330 } ];
	predefineIntersectText[3] = [ { &quot;id&quot;: &quot;1in2&quot;, &quot;textX&quot;: 290, &quot;textY&quot;: 330 },
					{ &quot;id&quot;: &quot;1in3&quot;, &quot;textX&quot;: 240, &quot;textY&quot;: 240,  },
					{ &quot;id&quot;: &quot;2in3&quot;, &quot;textX&quot;: 340, &quot;textY&quot;: 240,  },
					{ &quot;id&quot;: &quot;1in2in3&quot;, &quot;textX&quot;: 290, &quot;textY&quot;: 270 } ];

	predefineIntersectText[4] = [ { &quot;id&quot;: &quot;1in2&quot;, &quot;textX&quot;: 146, &quot;textY&quot;: 127 },
					{ &quot;id&quot;: &quot;1in3&quot;, &quot;textX&quot;: 194, &quot;textY&quot;: 311 },
					{ &quot;id&quot;: &quot;1in4&quot;, &quot;textX&quot;: 294, &quot;textY&quot;: 368 },
					{ &quot;id&quot;: &quot;2in3&quot;, &quot;textX&quot;: 291, &quot;textY&quot;: 118 },
					{ &quot;id&quot;: &quot;2in4&quot;, &quot;textX&quot;: 389, &quot;textY&quot;: 309 },
					{ &quot;id&quot;: &quot;3in4&quot;, &quot;textX&quot;: 433, &quot;textY&quot;: 141 },
					{ &quot;id&quot;: &quot;1in2in3&quot;, &quot;textX&quot;: 223, &quot;textY&quot;: 201 }, 
					{ &quot;id&quot;: &quot;1in2in4&quot;, &quot;textX&quot;: 341, &quot;textY&quot;: 328 },
					{ &quot;id&quot;: &quot;1in3in4&quot;, &quot;textX&quot;: 246, &quot;textY&quot;: 329 },
					{ &quot;id&quot;: &quot;2in3in4&quot;, &quot;textX&quot;: 366, &quot;textY&quot;: 208 },
					{ &quot;id&quot;: &quot;1in2in3in4&quot;, &quot;textX&quot;: 290, &quot;textY&quot;: 278 } ]

	predefineIntersectText[5] = [ { &quot;id&quot;: &quot;1in2in3in4in5&quot;, &quot;textX&quot;: 236, &quot;textY&quot;: 250 } ];
	predefineIntersectText[6] = [ { &quot;id&quot;: &quot;1in2in3in4in5in6&quot;, &quot;textX&quot;: 200.66335, &quot;textY&quot;: 217.0728 } ];
	predefineIntersectText[7] = [ { &quot;id&quot;: &quot;1in2in3in4in5in6in7&quot;, &quot;textX&quot;: 236, &quot;textY&quot;: 250 } ];

	//magic finished
	predefineColor = [ &quot;&quot;,&quot;red&quot;, &quot;orange&quot;, &quot;#BABA00&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;indigo&quot;, &quot;violet&quot;, &quot;brown&quot; ];

	//define drawing canvas/
	var w = 650, h = 650;

	var svg = d3.select( &quot;#&quot; + target )
	.append(&quot;svg&quot;)
	.attr(&quot;width&quot;, w)
	.attr(&quot;height&quot;, h);

    var tooltip = d3.select(&quot;body&quot;).append(&quot;div&quot;)
		.attr( &quot;id&quot;, &quot;vennToolTip&quot; )
		.style(&quot;position&quot;, &quot;absolute&quot;)
		.style(&quot;text-align&quot;, &quot;center&quot;)
		.style(&quot;width&quot;, &quot;220px&quot;)
		.style(&quot;background&quot;, &quot;#333&quot;)
		.style(&quot;color&quot;, &quot;#ddd&quot;)
		.style(&quot;border&quot;, &quot;0px&quot;)
		.style(&quot;border-radius&quot;, &quot;8px&quot;)
		.style(&quot;opacity&quot;, 0);

	tooltip.append( &quot;p&quot; )
		.append( &quot;strong&quot; ).attr(&quot;id&quot;, &quot;vennToolTipTitle&quot;).style( &quot;color&quot;, &quot;white&quot; );

	tooltip.append( &quot;p&quot; )
		.attr(&quot;id&quot;, &quot;vennToolTipListSize&quot;).style( &quot;color&quot;, &quot;white&quot; );

	tooltip.append( &quot;div&quot; )
		.attr(&quot;id&quot;, &quot;vennToolTipList&quot;).style( &quot;color&quot;, &quot;white&quot; );
    
    if ( clickCallback )
    	clickChartCallback = clickCallback;

    if ( lists )
    	this.updateAllList( lists );
}

exports.BioJSVenn.prototype = VennPrototype;</code></pre>
        </div>
      </div>
    </div>
    <footer class="footer">
      <div class="container">
        <p>Documentation generated with <a href="https://github.com/FGRibreau/doxx">Doxx </a> created by <a href="https://twitter.com/FGRibreau" data-show-count="false" class="twitter-follow-button">Francois-Guillaume Ribreau </a></p>
        <p>Doxx is sponsored by <a href="http://bringr.net/?btt" title="Outil d'analyse des rseaux sociaux" class="bringr">Bringr </a> and <a href="https://redsmin.com/?btt" title="Full Redis GUI" class="redsmin">Redsmin</a></p>
        <p>Theme borrowed from Twitter Bootstrap</p>
      </div>
    </footer>
    <script src="http://platform.twitter.com/widgets.js"></script>
    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1.8/jquery.min.js"></script>
    <script src="http://leaverou.github.com/prefixfree/prefixfree.js"></script>
    <script src="http://getbootstrap.com/2.3.2/assets/js/bootstrap-transition.js"></script>
    <script src="http://getbootstrap.com/2.3.2/assets/js/bootstrap-scrollspy.js"></script>
    <script src="http://getbootstrap.com/2.3.2/assets/js/bootstrap-dropdown.js"></script>
    <script src="http://getbootstrap.com/2.3.2/assets/js/bootstrap-collapse.js"></script>
    <script src="http://getbootstrap.com/2.3.2/assets/js/bootstrap-affix.js"></script>
    <script>
      /**
       * Prism: Lightweight, robust, elegant syntax highlighting
       * MIT license http://www.opensource.org/licenses/mit-license.php/
       * @author Lea Verou http://lea.verou.me
       */(function(){var e=/\blang(?:uage)?-(?!\*)(\w+)\b/i,t=self.Prism={util:{type:function(e){return Object.prototype.toString.call(e).match(/\[object (\w+)\]/)[1]},clone:function(e){var n=t.util.type(e);switch(n){case"Object":var r={};for(var i in e)e.hasOwnProperty(i)&&(r[i]=t.util.clone(e[i]));return r;case"Array":return e.slice()}return e}},languages:{extend:function(e,n){var r=t.util.clone(t.languages[e]);for(var i in n)r[i]=n[i];return r},insertBefore:function(e,n,r,i){i=i||t.languages;var s=i[e],o={};for(var u in s)if(s.hasOwnProperty(u)){if(u==n)for(var a in r)r.hasOwnProperty(a)&&(o[a]=r[a]);o[u]=s[u]}return i[e]=o},DFS:function(e,n){for(var r in e){n.call(e,r,e[r]);t.util.type(e)==="Object"&&t.languages.DFS(e[r],n)}}},highlightAll:function(e,n){var r=document.querySelectorAll('code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code');for(var i=0,s;s=r[i++];)t.highlightElement(s,e===!0,n)},highlightElement:function(r,i,s){var o,u,a=r;while(a&&!e.test(a.className))a=a.parentNode;if(a){o=(a.className.match(e)||[,""])[1];u=t.languages[o]}if(!u)return;r.className=r.className.replace(e,"").replace(/\s+/g," ")+" language-"+o;a=r.parentNode;/pre/i.test(a.nodeName)&&(a.className=a.className.replace(e,"").replace(/\s+/g," ")+" language-"+o);var f=r.textContent;if(!f)return;f=f.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/\u00a0/g," ");var l={element:r,language:o,grammar:u,code:f};t.hooks.run("before-highlight",l);if(i&&self.Worker){var c=new Worker(t.filename);c.onmessage=function(e){l.highlightedCode=n.stringify(JSON.parse(e.data));l.element.innerHTML=l.highlightedCode;s&&s.call(l.element);t.hooks.run("after-highlight",l)};c.postMessage(JSON.stringify({language:l.language,code:l.code}))}else{l.highlightedCode=t.highlight(l.code,l.grammar);l.element.innerHTML=l.highlightedCode;s&&s.call(r);t.hooks.run("after-highlight",l)}},highlight:function(e,r){return n.stringify(t.tokenize(e,r))},tokenize:function(e,n){var r=t.Token,i=[e],s=n.rest;if(s){for(var o in s)n[o]=s[o];delete n.rest}e:for(var o in n){if(!n.hasOwnProperty(o)||!n[o])continue;var u=n[o],a=u.inside,f=!!u.lookbehind||0;u=u.pattern||u;for(var l=0;l<i.length;l++){var c=i[l];if(i.length>e.length)break e;if(c instanceof r)continue;u.lastIndex=0;var h=u.exec(c);if(h){f&&(f=h[1].length);var p=h.index-1+f,h=h[0].slice(f),d=h.length,v=p+d,m=c.slice(0,p+1),g=c.slice(v+1),y=[l,1];m&&y.push(m);var b=new r(o,a?t.tokenize(h,a):h);y.push(b);g&&y.push(g);Array.prototype.splice.apply(i,y)}}}return i},hooks:{all:{},add:function(e,n){var r=t.hooks.all;r[e]=r[e]||[];r[e].push(n)},run:function(e,n){var r=t.hooks.all[e];if(!r||!r.length)return;for(var i=0,s;s=r[i++];)s(n)}}},n=t.Token=function(e,t){this.type=e;this.content=t};n.stringify=function(e){if(typeof e=="string")return e;if(Object.prototype.toString.call(e)=="[object Array]"){for(var r=0;r<e.length;r++)e[r]=n.stringify(e[r]);return e.join("")}var i={type:e.type,content:n.stringify(e.content),tag:"span",classes:["token",e.type],attributes:{}};i.type=="comment"&&(i.attributes.spellcheck="true");t.hooks.run("wrap",i);var s="";for(var o in i.attributes)s+=o+'="'+(i.attributes[o]||"")+'"';return"<"+i.tag+' class="'+i.classes.join(" ")+'" '+s+">"+i.content+"</"+i.tag+">"};if(!self.document){self.addEventListener("message",function(e){var n=JSON.parse(e.data),r=n.language,i=n.code;self.postMessage(JSON.stringify(t.tokenize(i,t.languages[r])));self.close()},!1);return}var r=document.getElementsByTagName("script");r=r[r.length-1];if(r){t.filename=r.src;document.addEventListener&&!r.hasAttribute("data-manual")&&document.addEventListener("DOMContentLoaded",t.highlightAll)}})();;
      Prism.languages.markup={comment:/&lt;!--[\w\W]*?--(&gt;|&gt;)/g,prolog:/&lt;\?.+?\?&gt;/,doctype:/&lt;!DOCTYPE.+?&gt;/,cdata:/&lt;!\[CDATA\[[\w\W]+?]]&gt;/i,tag:{pattern:/&lt;\/?[\w:-]+\s*(?:\s+[\w:-]+(?:=(?:("|')(\\?[\w\W])*?\1|\w+))?\s*)*\/?&gt;/gi,inside:{tag:{pattern:/^&lt;\/?[\w:-]+/i,inside:{punctuation:/^&lt;\/?/,namespace:/^[\w-]+?:/}},"attr-value":{pattern:/=(?:('|")[\w\W]*?(\1)|[^\s>]+)/gi,inside:{punctuation:/=|&gt;|"/g}},punctuation:/\/?&gt;/g,"attr-name":{pattern:/[\w:-]+/g,inside:{namespace:/^[\w-]+?:/}}}},entity:/&amp;#?[\da-z]{1,8};/gi};Prism.hooks.add("wrap",function(e){e.type==="entity"&&(e.attributes.title=e.content.replace(/&amp;/,"&"))});;
      Prism.languages.css={comment:/\/\*[\w\W]*?\*\//g,atrule:/@[\w-]+?(\s+[^;{]+)?(?=\s*{|\s*;)/gi,url:/url\((["']?).*?\1\)/gi,selector:/[^\{\}\s][^\{\}]*(?=\s*\{)/g,property:/(\b|\B)[a-z-]+(?=\s*:)/ig,string:/("|')(\\?.)*?\1/g,important:/\B!important\b/gi,ignore:/&(lt|gt|amp);/gi,punctuation:/[\{\};:]/g};Prism.languages.markup&&Prism.languages.insertBefore("markup","tag",{style:{pattern:/(&lt;|<)style[\w\W]*?(>|&gt;)[\w\W]*?(&lt;|<)\/style(>|&gt;)/ig,inside:{tag:{pattern:/(&lt;|<)style[\w\W]*?(>|&gt;)|(&lt;|<)\/style(>|&gt;)/ig,inside:Prism.languages.markup.tag.inside},rest:Prism.languages.css}}});;
      Prism.languages.clike={comment:{pattern:/(^|[^\\])(\/\*[\w\W]*?\*\/|\/\/.*?(\r?\n|$))/g,lookbehind:!0},string:/("|')(\\?.)*?\1/g,keyword:/\b(if|else|while|do|for|return|in|instanceof|function|new|try|catch|finally|null|break|continue)\b/g,"boolean":/\b(true|false)\b/g,number:/\b-?(0x)?\d*\.?[\da-f]+\b/g,operator:/[-+]{1,2}|!|=?&lt;|=?&gt;|={1,2}|(&amp;){1,2}|\|?\||\?|\*|\//g,ignore:/&(lt|gt|amp);/gi,punctuation:/[{}[\];(),.:]/g};;
      Prism.languages.javascript=Prism.languages.extend("clike",{keyword:/\b(var|let|if|else|while|do|for|return|in|instanceof|function|new|with|typeof|try|catch|finally|null|break|continue)\b/g,number:/\b(-?(0x)?\d*\.?[\da-f]+|NaN|-?Infinity)\b/g});Prism.languages.insertBefore("javascript","keyword",{regex:{pattern:/(^|[^/])\/(?!\/)(\[.+?]|\\.|[^/\r\n])+\/[gim]{0,3}(?=\s*($|[\r\n,.;})]))/g,lookbehind:!0}});Prism.languages.markup&&Prism.languages.insertBefore("markup","tag",{script:{pattern:/(&lt;|<)script[\w\W]*?(>|&gt;)[\w\W]*?(&lt;|<)\/script(>|&gt;)/ig,inside:{tag:{pattern:/(&lt;|<)script[\w\W]*?(>|&gt;)|(&lt;|<)\/script(>|&gt;)/ig,inside:Prism.languages.markup.tag.inside},rest:Prism.languages.javascript}}});;
      
    </script>
    <!-- App js-->
    <script>
      $(function(){
        var $window = $(window);
        $('.scrollspy .nav').affix({
          offset: {
            top: function () { return $window.width() <= 980 ? 480 : 400 }
          , bottom: 50
          }
        });
      })
    </script>
  </body>
</html>